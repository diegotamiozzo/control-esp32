#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <WiFiManager.h>
#include <DHT.h>
#include <ArduinoJson.h>
#include <Preferences.h>

// =================================================================
// 1. CONFIGURAÇÕES GLOBAIS
// =================================================================

// --- CONFIGURAÇÕES DO HIVE MQ ---
const char* mqtt_server = "72c037df4ced415995ef95169a5c7248.s1.eu.hivemq.cloud";
const int mqtt_port = 8883;
const char* mqtt_user = "esp32_cliente02";
const char* mqtt_pass = "Corcel@73";

// --- CERTIFICADO RAIZ (ROOT CA) DO HIVE MQ ---
// **SUBSTITUA** pelo Root CA do seu cluster HiveMQ.
const char* root_ca = \
                      "-----BEGIN CERTIFICATE-----\n" \
                      "MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\n" \
                      "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
                      "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\n" \
                      "WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\n" \
                      "ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\n" \
                      "MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc\n" \
                      "h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+\n" \
                      "0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U\n" \
                      "A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW\n" \
                      "T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH\n" \
                      "B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC\n" \
                      "B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv\n" \
                      "KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn\n" \
                      "OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn\n" \
                      "jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw\n" \
                      "qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI\n" \
                      "rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\n" \
                      "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq\n" \
                      "hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\n" \
                      "ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ\n" \
                      "3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK\n" \
                      "NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5\n" \
                      "ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur\n" \
                      "TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC\n" \
                      "jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb/ZAJzVc\n" \
                      "oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq\n" \
                      "4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA\n" \
                      "mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d\n" \
                      "emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n" \
                      "-----END CERTIFICATE-----\n";



// --- PINS E ATUADORES ---
#define DHT_PIN 4
#define DHT_TYPE DHT11
const int RELAY_PIN_TEMP = 25;
const int RELAY_PIN_HUM  = 26;
const int RELAY_PIN_MAN3 = 27;
const int RELAY_PIN_MAN4 = 14;

// =================================================================
// 2. VARIÁVEIS DE ESTADO E PERSISTÊNCIA
// =================================================================

// Set Points e Histerese
float temp_set_point = 25.0;
float hum_set_point  = 60.0;
const float HYSTERESIS = 2.0;

// Leituras atuais
float current_temp = 0.0;
float current_hum = 0.0;

// Estado dos relés
int relay_state[4] = {LOW, LOW, LOW, LOW};

// Identificação Única e Tópicos (Calculados no Setup)
char client_id[32];
char topic_telemetry[64];
char topic_command[64];
char topic_lwt[64];

// =================================================================
// 3. OBJETOS
// =================================================================

WiFiClientSecure espClient;
PubSubClient client(espClient);
WiFiManager wm;
DHT dht(DHT_PIN, DHT_TYPE);
Preferences preferences; // Novo: Objeto de persistência

// =================================================================
// 4. PERSISTÊNCIA (NVS)
// =================================================================

// Carrega Set Points salvos na memória NVS
void loadSettings() {
  preferences.begin("iot-config", true); // "read only" = true

  // Carrega os valores, usando valores padrão se não existirem
  temp_set_point = preferences.getFloat("sp_t", 25.0);
  hum_set_point  = preferences.getFloat("sp_h", 60.0);

  preferences.end();

  Serial.println("--- NVS Settings Loaded ---");
  Serial.print("Temp SP: "); Serial.println(temp_set_point);
  Serial.print("Hum SP: "); Serial.println(hum_set_point);
  Serial.println("---------------------------");
}

// Salva Set Points na memória NVS
void saveSettings() {
  preferences.begin("iot-config", false); // "read only" = false (Read/Write mode)

  preferences.putFloat("sp_t", temp_set_point);
  preferences.putFloat("sp_h", hum_set_point);

  preferences.end();
  Serial.println("Settings saved to NVS.");
}


// =================================================================
// 5. FUNÇÕES MQTT
// =================================================================

void publishTelemetry() {
  if (!client.connected()) return;

  StaticJsonDocument<256> doc;
  doc["temp"] = current_temp;
  doc["hum"] = current_hum;
  doc["sp_temp"] = temp_set_point;
  doc["sp_hum"] = hum_set_point;
  doc["rele1"] = relay_state[0];
  doc["rele2"] = relay_state[1];
  doc["rele3"] = relay_state[2];
  doc["rele4"] = relay_state[3];

  char payload[256];
  serializeJson(doc, payload);

  client.publish(topic_telemetry, payload, false);
}

void reconnect() {
  // A configuração do certificado está correta.
  espClient.setCACert(root_ca);

  while (!client.connected()) {
    Serial.print("Tentando conexão MQTT...");

    // NOVO: Conexão simplificada, SEM LWT.
    if (client.connect(client_id, mqtt_user, mqtt_pass)) {
      Serial.println("Conectado ao HiveMQ!");

      // Publicar o estado 'online' e subscrever o tópico de comando
      // Mantenha o publish do estado 'online' (agora sem ser LWT)
      client.publish(topic_lwt, "online", true);
      client.subscribe(topic_command);

    } else {
      Serial.print("Falha, rc=");
      Serial.print(client.state());
      Serial.println(" Tentando em 5 segundos...");
      delay(5000);
    }
  }
}

// =================================================================
// 6. LÓGICA DE CONTROLE E CALLBACK
// =================================================================

void apply_relay_states() {
  digitalWrite(RELAY_PIN_TEMP, relay_state[0]);
  digitalWrite(RELAY_PIN_HUM, relay_state[1]);
  digitalWrite(RELAY_PIN_MAN3, relay_state[2]);
  digitalWrite(RELAY_PIN_MAN4, relay_state[3]);
}

void check_set_points() {
  // --- RELÉ 1: Controle de TEMPERATURA (aciona se muito frio) ---
  if (current_temp < (temp_set_point - HYSTERESIS) && relay_state[0] == LOW) {
    relay_state[0] = HIGH;
  }
  else if (current_temp > temp_set_point && relay_state[0] == HIGH) {
    relay_state[0] = LOW;
  }

  // --- RELÉ 2: Controle de UMIDADE (aciona se muito úmido) ---
  if (current_hum > (hum_set_point + HYSTERESIS) && relay_state[1] == LOW) {
    relay_state[1] = HIGH;
  }
  else if (current_hum < hum_set_point && relay_state[1] == HIGH) {
    relay_state[1] = LOW;
  }

  apply_relay_states();
}


void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Comando Recebido. ");

  char message[length + 1];
  memcpy(message, payload, length);
  message[length] = '\0';

  StaticJsonDocument<128> doc;
  DeserializationError error = deserializeJson(doc, message);

  if (error) {
    Serial.println(F("Falha ao analisar JSON de comando."));
    return;
  }

  bool settings_changed = false;

  // --- COMANDOS MANUAIS (Reles 3 e 4) ---
  if (doc.containsKey("r3")) {
    relay_state[2] = doc["r3"].as<bool>() ? HIGH : LOW;
  }
  if (doc.containsKey("r4")) {
    relay_state[3] = doc["r4"].as<bool>() ? HIGH : LOW;
  }

  // --- COMANDOS DE SET POINT ---
  if (doc.containsKey("sp_t")) {
    temp_set_point = doc["sp_t"].as<float>();
    settings_changed = true;
  }
  if (doc.containsKey("sp_h")) {
    hum_set_point = doc["sp_h"].as<float>();
    settings_changed = true;
  }

  // Salva na memória NVS se os Set Points mudaram
  if (settings_changed) {
    saveSettings();
  }

  apply_relay_states();
  publishTelemetry();
}

// =================================================================
// 7. SETUP E LOOP PRINCIPAL
// =================================================================

void setup() {
    Serial.begin(115200);
    dht.begin();
    
    // --- CARREGA SET POINTS SALVOS (PERSISTÊNCIA) ---
    loadSettings(); 

    // Configuração dos Pinos dos Relés (Mantenha aqui)
    pinMode(RELAY_PIN_TEMP, OUTPUT); digitalWrite(RELAY_PIN_TEMP, relay_state[0]);
    pinMode(RELAY_PIN_HUM, OUTPUT);  digitalWrite(RELAY_PIN_HUM, relay_state[1]);
    pinMode(RELAY_PIN_MAN3, OUTPUT); digitalWrite(RELAY_PIN_MAN3, relay_state[2]);
    pinMode(RELAY_PIN_MAN4, OUTPUT); digitalWrite(RELAY_PIN_MAN4, relay_state[3]);

    // --- WIFI MANAGER (PORTAL CATIVO) ---
    wm.setAPCallback([](WiFiManager *myWiFiManager) {
        Serial.println("Entrou no Portal Cativo (Modo AP)");
    });

    if (!wm.autoConnect("ESP32_IOT_SETUP", "senha123")) { 
        Serial.println("Falha de conexao Wi-Fi. Reiniciando...");
        delay(3000);
        ESP.restart();
    } 
    Serial.println("Conectado ao Wi-Fi!");

    // =========================================================
    // <<< Mova o bloco de GERAÇÃO DE IDs para AQUI! >>>
    // =========================================================
    // --- GERAÇÃO DE IDs E TÓPICOS ÚNICOS ---
    String mac = WiFi.macAddress();
    mac.replace(":", "");
    mac.toCharArray(client_id, 32);

    snprintf(topic_telemetry, 64, "dispositivo/%s/telemetria", client_id);
    snprintf(topic_command, 64, "dispositivo/%s/comando", client_id);
    snprintf(topic_lwt, 64, "dispositivo/%s/conexao", client_id);
    
    Serial.print("Client ID (MAC Address): ");
    Serial.println(client_id);
    // =========================================================

    // --- CONFIGURAÇÃO MQTT ---
    client.setServer(mqtt_server, mqtt_port);
    client.setCallback(callback);

    reconnect();
}

void loop() {
  // 1. Manutenção da conexão MQTT
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // 2. Lógica de Leitura e Publicação
  static unsigned long last_publish = 0;
  static unsigned long last_read = 0;
  const long READ_INTERVAL = 2000;
  const long PUBLISH_INTERVAL = 10000;

  if (millis() - last_read > READ_INTERVAL) {
    // --- NOVO: LÓGICA DE PROTEÇÃO CONTRA FALHA DO SENSOR ---
    float h_new = dht.readHumidity();
    float t_new = dht.readTemperature();

    // Verifica se a leitura é válida
    if (!isnan(h_new) && !isnan(t_new)) {
      current_hum = h_new;
      current_temp = t_new;
      // APLICAR CONTROLE SOMENTE SE A LEITURA FOR VÁLIDA
      check_set_points();
      Serial.println("Leitura DHT OK. Controle aplicado.");
    } else {
      // Se a leitura falhar, mantemos os valores anteriores (current_hum/temp)
      // O estado dos relés é mantido pelo check_set_points() anterior.
      Serial.println("!!! FALHA DE SENSOR. Mantendo estados anteriores dos reles.");
    }
    last_read = millis();
  }

  if (millis() - last_publish > PUBLISH_INTERVAL) {
    publishTelemetry();
    last_publish = millis();
  }
}